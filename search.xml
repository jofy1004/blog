<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git和coding多仓库提交]]></title>
    <url>%2Fblog%2F2020%2F06%2F30%2FgitAndCodingDeploy%2F</url>
    <content type="text"><![CDATA[引言想把代码既提交到github，又提交到coding该如何做呢？ 创建账号、创建项目这两个网站都需要账号（废话），接着创建两个空项目（废话），把代码库地址记住，然后创建publickey； 创建publickey1ssh-keygen -t rsa -C &quot;邮箱地址&quot; 名字可以随便定义，要区分开git和coding，比如我把github的key就放在了github文件夹下，如下图： 然后一路回车完毕，在对应存放的地址中找到id_rsa.pub文件 打开后复制串，然后打开github创建ssh key； coding创建publickey同上； 关联代码仓库如果以前代码关联过远程仓库，需要移除的话请使用下面命令1git remote rm origin 注意，现在远程仓库既有github，又有coding，所以远程仓库就不能使用默认的origin，我们要给他起特殊名字，比如往github提交，起的名字就是github1git remote add github git@github.com:jofy1004/blog-factory.git 往coding提交，起的名字就叫coding1git remote add coding git@e.coding.net:jofy1004/blog-factory.git 然后查看绑定的远程仓库1git remote -v 推送代码推送代码分别使用123git push github mastergit push coding master 这时候发现推送不成功 错误是设置的key不对，使用命令1ssh -v git@github.com 我们改过名字的key，没有识别到，所以要把改过名字的key加到里面，使用命令123ssh-add C:/Users/ccc-zhoufei/.ssh/github/id_rsassh-add C:/Users/ccc-zhoufei/.ssh/coding/id_rsa 如果使用以上命令出错，请先执行1eval $(ssh-agent) 设置完成后，在执行push，就可以分别推送到远程分支了；]]></content>
      <categories>
        <category>学习交流</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shadowsocks安装]]></title>
    <url>%2Fblog%2F2020%2F06%2F09%2Fshadowsocks-install%2F</url>
    <content type="text"><![CDATA[引言今天又把shadowsocks拿出来配置，看看到底为啥不成功，话不多说，直接开始。 分步安装版 我使用的是CentOS 8，安装的是python3。1yum -y install python36 输入命令，查看版本显示错误。 1python --version 这是由于没有指定默认，设置默认值 1sudo alternatives --set python /usr/bin/python3 接下来安装python-pip 1curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py 最后安装shadowsocks 1pip install shadowsocks 创建shadowsocks.json文件 1vim /etc/shadowsocks.json 将以下文本copy进去，保存 1234567//此处进入vim文件编辑&#123; "server": "0.0.0.0",//这里不用改，全0代表地服务器监所有可用网络。 "server_port": 6356,//服务器端口号，1025到65535任选一。 "password": "mima123321",//设置登录密码。 "method": "rc4-md5"//加密方式。&#125; 然后创建自启动服务 1vim /etc/systemd/system/shadowsocks.service 将以下文本copy进去，保存 1234567891011# 这里进入vim文件编辑# 脚本内容如下：[Unit]Description=Shadowsocks[Service]TimeoutStartSec=0ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json[Install]WantedBy=multi-user.target 启动、停止、查看状态 123systemctl enable shadowsockssystemctl start shadowsockssystemctl status shadowsocks -l 很不幸的告诉大家，按照以上配置我没有成功启动，哇哈哈哈哈哈哈哈哈，服务器一直启动失败，不知所以然。 一键配置版 参考文章：CentOS下shadowsocks一键安装脚本 这个版本成功了，我怀疑分步版，可能创建json文件，里面编码集或者字符导致的问题。 下载别人写好的配置命令文件 1wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh 给此文件赋权限 1chmod +x shadowsocks.sh 直接运行脚本 1./shadowsocks.sh 一步步跟着提示配置完，会显示成功，但是我试过几个脚本，虽然配置成功了，但是并没有启动，所以要查看服务状态，对应的命令如下： 1234/etc/init.d/shadowsocks start/etc/init.d/shadowsocks stop/etc/init.d/shadowsocks restart/etc/init.d/shadowsocks status 最后测试 下载小飞机，连接测试成功，很奇怪，为啥最开始不行呢。]]></content>
      <categories>
        <category>学习交流</category>
      </categories>
      <tags>
        <tag>vpn</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个妹子图的小爬虫]]></title>
    <url>%2Fblog%2F2020%2F05%2F22%2Fweb-crawler-mzitu%2F</url>
    <content type="text"><![CDATA[引言继昨天搭建好了自己的vpn后，本着闲来无事要生事的原则，想起了朋友前几天说的python爬虫，随手就找了篇文章，依葫芦画瓢起来；本人不会python，所以只能现学现卖； 参考文章：小白爬虫第一弹之抓取妹子图 搭建环境 安装python环境，下载地址安装完成，打开cmd，查看安装是否成功。1py --version 开发工具用的PyCharm的windows Professional版。 创建项目 贴图直观，跟着下图一步一步 获取依赖库requests是使用Apache2 licensed许可证的HTTP库；beautifulsoup是python用于html/xml文件中提取数据的库；lxml是python对于html/xml解析库，支持XPath解析方式，而且解析效率非常高； 123pip install requestspip install beautifulsoup4pip install lxml 分析网页元素，找到共同点, 首先目标网站是妹子图； 接下来是图片的链接，因为这些链接打开后，才是批量的图片，我们的目标就是这些连接下所有的图片； F12、空白处右键-&gt;查看、Ctrl+Shift+i，都可以调出windows下chrome浏览器的控制台，如下图所示，目标就是&lt;ul class=”archives”&gt;标签下的&lt;a href=”**“&gt;标签里的href数据，如果打开这个链接，那么就能看到这个标题下的所有图片； 打开这个链接后，看到地址栏的地址中最后一位与翻页页码对应，也就是改变链接最后一位数字就可以拿到对应页码的图片，而图片真正的地址就在img标签的src中，只要有这个地址，就能拿到图片。 代码如下，github下载源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import requestsfrom bs4 import BeautifulSoupimport os# 获取除了图片以外的HTML页面def getHTMLText(url, code='utf-8'): # 定义请求头 headers = &#123; 'User-Agent': "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1"&#125; # 发出get请求获取html页面资源 html = requests.get(url, headers=headers) # 转成BeautifulSoup，可以供查询标签使用 return BeautifulSoup(html.text, 'lxml')# 按照分类创建输入目录def mkdir(root_path, path): # 拼接存放图片的绝对路径 path = os.path.join(root_path, str(path).strip()) # 判断此路径是否已经存在 if os.path.exists(path): # 进入到此文件夹中 os.chdir(path) return path else: # 不存在，创建此路径 os.makedirs(path) # 进入到此文件夹中 os.chdir(path) return path# 主程序入口def main(): # 获取图片存放的绝对路径 root_path = os.path.abspath(os.path.dirname('search.py')) # 获取mzitu的Soup，用于后续查找使用 main_page_soup = getHTMLText('https://www.mzitu.com/all/') # 查找每个需要打开的连接，打开这个连接后，里面的图片才是真正需要的爬的数据 list_url = main_page_soup.find('div', class_='all').find('ul').find_all('a') # 获取到所有url，循环打开，获取里面图片 for url in list_url: # 获取到连接的内容，座位输出文件夹的名称，可以做到分类输出 title = url.get_text() # 按照标题创建文件夹，并进入到此文件夹，准备后续写入图片 mkdir(root_path + '/www.mzitu.com', title) # 获取每类标题图片的链接 href = url['href'] # 防盗链 ref_headers = &#123;'referer': href, 'User-Agent': "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1"&#125; # 获取最大页码数 # html_soup = getHTMLText(href) # max_num = html_Soup.find('div', class_='pagenavi').find_all('span')[-2].get_text() # 图片页码太多，所以这里我使用了固定5页，有需要全部的，把5可以替换成max_num+1 for page in range(1, 5): # 由于图片有分页，每个图片翻页连接刚好是页码数，所以拼接页码数地址 page_url = href + '/' + str(page) # 获取图片HTML元素 picture_soup = getHTMLText(page_url) # 获取图片地址 img_url = picture_soup.find('div', class_='main-image').find('img')['src'] # 图片的url截取作为图片名称 name = img_url[-9:-4] # 请求图片资源 img = requests.get(img_url, headers=ref_headers) # 获取图片流 f = open(name + '.jpg', 'ab') # 图片写道本地磁盘 f.write(img.content) # 关闭写出流 f.close() print(img_url)main() 执行结果 生成可执行文件 python代码完成，总不能在别人的计算机上也装上依赖库，运行环境吧，接下来交给大家如何将写好的程序转换为.exe可执行文件。 1pip install pyinstaller 等待结束后，查看版本，确认安装完成 1pyinstaller --version 执行生成 1pyinstaller -F search.py 测试可执行文件]]></content>
      <categories>
        <category>学习交流</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>crawler</tag>
        <tag>mzitu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建自己的VPN服务]]></title>
    <url>%2Fblog%2F2020%2F05%2F21%2Fprivate-vpn%2F</url>
    <content type="text"><![CDATA[引言最近vpn查封的较严，导致我的chrome无法登录，邮箱无法打开，书签无法同步，我又是个懒人，不想搞书签导出什么的，所以就想自己搭个vpn服务，仅做学习交流使用。 首先我们需要个国外的VPS国外有好多VPS服务商，有的不支持中文，对于二把刀英语的我来说麻烦；有的由于**，不支持VPN服务，反正各种原因，最后选了HostMem,支持中文，支持vpn，最便宜的$12.99/年，价格合理。买之，创建了经典云服务器，服务器信息都可以在概括中找到，用xshell直接连接； 创建VPN服务最开始选用的是shadowsocks，服务端好了，客户端用小飞机，就是连接不成功。不知道缘由，没办法改成了openVPN; 开始openVPN服务端配置 参考文章：在RHEL/CentOS 8上安装和配置OpenVPN Server的方法使用nmcli连接到Linux系统中的OpenVPN Server 下载git因为要去github获取openVPN的安装文件1sudo dnf -y install git 下载openVPN1git clone https://github.com/Nyr/openvpn-install.git 执行安装openVPN进入openvpn-install目录，执行安装脚本12chmod +x openvpn-install.shsudo ./openvpn-install.sh 创建服务端一路飙车（Enter、Enter…），成功后，到此openVPN的服务端就配置好了，配置文件在/etc/openvpn/server/server.conf。 生成客户端接下来要生成客户端配置文件，供客户端连接使用12cd /etc/openvpn-installsudo ./openvpn-install.sh 下载客户端配置文件生成的客户端文件保存至/root下面，把它下载下来一会要配置客户端使用。友情提醒：下面这个命令要在客户端机器执行；1scp 用户名@IP:/root/文件全名 本机保存地址 安装客户端应用下载客户端，我是window10，所以下载win10版本的客户端，长这样↓ 连接服务端安装好后，打开提示，需要配置文件，把下载好的客户端文件按照路径放进去，我放在了安装目录下的/config文件夹中。客户端打开找不到看右下角 测试接下来，连接之，然后测试 成功。。。]]></content>
      <categories>
        <category>学习交流</category>
      </categories>
      <tags>
        <tag>openVPN</tag>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodeJS生成JWT]]></title>
    <url>%2Fblog%2F2019%2F04%2F01%2Fjwt-for-nodejs%2F</url>
    <content type="text"><![CDATA[引言最近开始着手一个前后端分离的项目，做到用户认证，使用JWT，不了解可以参看JSON Web Token 入门教程,由于后端代码还没有，所以需要使用nodeJS模拟生成出JWT串，返回给前端使用。 如何生成要使用nodeJS生成非常简单，就像把大象装进冰箱一样，只要三步： 引入依赖组件 1npm install jsonwebtoken --save 加入到文件中，调用sign方法生成； 123let jwt = require('jsonwebtoken');let token = jwt.sign(&#123;/** **/&#125;); 输出到前端； 1ctx.response.body = token; 详细解说sign方法sign方法里面需要参数，可以参照JWT给出的说明来填写，官网给出很多语言的帮助文档，比如本文用的NodeJS：跳转到帮助文档后，可以看到sign方法需要三个参数1jwt.sign(payload, secretOrPrivateKey, [options, callback]) 第一个参数payloadJSON对象，把自己想要输出的数据都放在这个对象里面；12345678910111213141516171819202122232425&#123; userName: user, user_name: "admin", urls: [ "/claim/getTaskList" ], authorities: [ "ROLE_USER" ], menus: &#123; personalMenu: [ &#123; field: "mobileSurvey", href: "mobileSurvey", type: "A01" &#125;, &#123; field: "injuryEst", href: "", type: "B02" &#125; ], managementMenu: [] &#125;&#125; 第二个参数密码串；非对称加密把私钥填在这儿； 第三个参数 algorithm：加密类型（默认：HS256） expiresIn：有效期；格式：zeit/ms（数字：60 为60秒；字符串：”2days”为2天，也可以写为”2d”；”10h”为10小时；如果字符串”60”不写单位为60毫秒） notBefore audience issuer jwtid subject noTimestamp header keyid mutatePayload:如果为真，sign函数将直接修改payload对象。如果您需要在对payload应用声明之后、但在将其编码为令牌之前对其进行原始引用，那么这是非常有用的。]]></content>
      <categories>
        <category>学习交流</category>
      </categories>
      <tags>
        <tag>jwt</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery-file-upload坑爹记]]></title>
    <url>%2Fblog%2F2019%2F03%2F28%2FjQuery-file-upload-issue-md%2F</url>
    <content type="text"><![CDATA[引言项目以前使用的SWFUpload上传组件，中文文档度娘随处可以搜到，基于js+flash，但是近几年谷爷越来越不待见flash，导致Chrome在加载flash的时候总要手动允许，而且关闭浏览器后再次打开还需要再次允许，使用非常不便，所以…jQuery File Upload是功能强大的jQuery上传组件，可以先看看DEMO，各种上传必须的功能都支持，如下： 多个文件同时上传 文件拖拽 上传进度条 支持取消上传 支持大文件上传 支持客户端改变图片尺寸 支持预览 无需任何flash插件 支持跨域上传 一个页面可以有多个上传控件 支持标准的multipart/form-data 也许是我理解力差，也许是我英语二把刀，使用官方给出的WIKI来实现我的功能，着实费了一番大工夫，来看看我踩得坑。 开始坑爹之路引入后js报错我使用的是可压缩图片的上传，参看官网Client side Image Resizing引入对应的js组件，按顺序，一定要按顺序；注意：canvas-to-blob.min.js、load-image.all.min.js组件里没有，你得自己下载；OK，一切就绪，启动上传，报错：这是_onSend()函数里面的错误，直接导致后续progress、fail、success无法执行；删除fail调用链，always报错，删除always调用链，一切正常；所以推测，可能是done函数的调用导致的问题，所以将源代码改了改将done移动到了最后位置，一切正常了。。。猜测是解决问题了，但是原因还有点懵，难道造成这个是我用的jQuery-1.11.3.js、jQuery-UI-1.10.3.js的原因吗？ 关于always源文件中给出always事件的注释如下：12// Callback for completed (success, abort or error) requests:// always: function (e, data) &#123;&#125;, // .bind('fileuploadalways', func); 我的理解是，在success, abort or error请求完成后，调用此事件，所以自热而然的理解为是调用完done(fileuploaddone)、fail(fileuploadfail)事件后，再调用always(fileuploadalways)，然而并不是，always是在这俩事件之前调用。 关于abort取消上传，官网给了样例，如下：Uploads can be canceled by invoking the abort method on a jqXHR object: 123456789var jqXHR = $(‘#fileupload’).fileupload(‘send’, &#123;files: filesList&#125;) .error(function (jqXHR, textStatus, errorThrown) &#123; if (errorThrown === ‘abort’) &#123; alert(‘File Upload has been canceled’); &#125; &#125;);$(‘button.cancel’).click(function (e) &#123; jqXHR.abort();&#125;); blueimpgithub.com/blueimp/jQuery-File-Upload/wiki/API如果要使用这个功能，需要保存所有上传对象，非常麻烦；后来发现在事件add中，第二个参数data有abort方法，直接调用就可以阻止上传；123.bind('fileuploadadd', function (e, data) &#123; data.abort();&#125;) 但是，data.abort()在其他事件中如send调用是无效，无法阻止；change事件里的data无abort方法； 关于全部阻止上传可以设置一个全局标志位，在fileuploadadd中加上判断，如果全局标志位阻止上传，那么执行data.abort()方法；反之不执行； 关于图片压缩官网给的样例如下：123456789101112$(‘#fileupload’).fileupload(&#123; url: ‘//jquery-file-upload.appspot.com/‘, dataType: ‘json’, // Enable image resizing, except for Android and Opera, // which actually support image resizing, but fail to // send Blob objects via XHR requests: disableImageResize: /Android(?!.*Chrome)|Opera/ .test(window.navigator &amp;&amp; navigator.userAgent), imageMaxWidth: 800, imageMaxHeight: 800, imageCrop: true // Force cropped images&#125;)blueimpgithub.com/blueimp/jQuery-File-Upload/wiki/Client-side-Image-ResizingdisableImageResize：false，就可以开启图片压缩； 关于上传图标样式1&lt;input type="file" id="jQueryFileUploadButton" name="Filedata" multiple/&gt; 由于此组件使用html原生上传按钮，那是非常难看，而且这个按钮还有个霸王条款，不许trigger(‘click’)来触发点击，只能鼠标点击；官方给出了解决办法：先做一个好看的按钮放在那，将上传按钮全透明后，覆盖在好看按钮上面，艾玛，没有做不到，只有想不到，大写的服气。。。 关于singleFileUploads1234// By default, each file of a selection is uploaded using an individual// request for XHR type uploads. Set to false to upload file// selections in one request each:singleFileUploads: true 这个意思是设置为true，一次可以选择多个图片，但是每个图片作为单独请求上传，那么change事件调用一次，add事件、send事件等会循环调用；12345678910111213141516....bind('fileuploadchange', function (e, data) &#123; // 调用一次 // data.files 是所有上传文件&#125;).bind('fileuploadadd', function (e, data) &#123; // 多次调用 // data.files 只有一个文件&#125;).bind('fileuploadsend', function (e, data) &#123; // 多次调用 // data.files 只有一个文件&#125;).bind('fileuploadprogress', function (e, data) &#123; // 每个文件单独的进度&#125;).bind('fileuploadprogressall', function (e, data) &#123; // 所有文件的进度&#125;)... 但是如果singleFileUploads: false,那就是把所有文件当做一个请求上传，所有的事件都只会调用一次，成功所有文件上传完成，一个失败，所有都没有上传。 关于事件调用1234567891011121314151617181920$('#fileupload').fileupload(&#123; url:'', autoUpload: true, sequentialUploads: true, change: function (e, data) &#123;/* ... */&#125;), add: function (e, data) &#123;/* ... */&#125;), send: function (e, data) &#123;/* ... */&#125;), ... &#125;);&#123;% endcodeblock %&#125;&#123;% codeblock lang:js %&#125;$('#fileupload').fileupload(&#123; url:'', autoUpload: true, sequentialUploads: true, &#125;) .bind('fileuploadchange', function (e, data) &#123;/* ... */&#125;) .bind('fileuploadadd', function (e, data) &#123;/* ... */&#125;) .bind('fileuploadsend', function (e, data) &#123;/* ... */&#125;);... 不要纠结，这两种绑定一样一样，爱用哪个就用哪个。 关于官网APIjQuery File Upload组件提供很多属性，但是官网API没有对应解释，只有个别样例，只能看源码里面的注释，作者很相信大家的能力。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197options: &#123; // The drop target element(s), by the default the complete document. // Set to null to disable drag &amp; drop support: dropZone: $(document), // The paste target element(s), by the default undefined. // Set to a DOM node or jQuery object to enable file pasting: pasteZone: undefined, // The file input field(s), that are listened to for change events. // If undefined, it is set to the file input fields inside // of the widget element on plugin initialization. // Set to null to disable the change listener. fileInput: undefined, // By default, the file input field is replaced with a clone after // each input field change event. This is required for iframe transport // queues and allows change events to be fired for the same file // selection, but can be disabled by setting the following option to false: replaceFileInput: true, // The parameter name for the file form data (the request argument name). // If undefined or empty, the name property of the file input field is // used, or "files[]" if the file input name property is also empty, // can be a string or an array of strings: paramName: undefined, // By default, each file of a selection is uploaded using an individual // request for XHR type uploads. Set to false to upload file // selections in one request each: singleFileUploads: true, // To limit the number of files uploaded with one XHR request, // set the following option to an integer greater than 0: limitMultiFileUploads: undefined, // The following option limits the number of files uploaded with one // XHR request to keep the request size under or equal to the defined // limit in bytes: limitMultiFileUploadSize: undefined, // Multipart file uploads add a number of bytes to each uploaded file, // therefore the following option adds an overhead for each file used // in the limitMultiFileUploadSize configuration: limitMultiFileUploadSizeOverhead: 512, // Set the following option to true to issue all file upload requests // in a sequential order: sequentialUploads: false, // To limit the number of concurrent uploads, // set the following option to an integer greater than 0: limitConcurrentUploads: undefined, // Set the following option to true to force iframe transport uploads: forceIframeTransport: false, // Set the following option to the location of a redirect url on the // origin server, for cross-domain iframe transport uploads: redirect: undefined, // The parameter name for the redirect url, sent as part of the form // data and set to 'redirect' if this option is empty: redirectParamName: undefined, // Set the following option to the location of a postMessage window, // to enable postMessage transport uploads: postMessage: undefined, // By default, XHR file uploads are sent as multipart/form-data. // The iframe transport is always using multipart/form-data. // Set to false to enable non-multipart XHR uploads: multipart: true, // To upload large files in smaller chunks, set the following option // to a preferred maximum chunk size. If set to 0, null or undefined, // or the browser does not support the required Blob API, files will // be uploaded as a whole. maxChunkSize: undefined, // When a non-multipart upload or a chunked multipart upload has been // aborted, this option can be used to resume the upload by setting // it to the size of the already uploaded bytes. This option is most // useful when modifying the options object inside of the "add" or // "send" callbacks, as the options are cloned for each file upload. uploadedBytes: undefined, // By default, failed (abort or error) file uploads are removed from the // global progress calculation. Set the following option to false to // prevent recalculating the global progress data: recalculateProgress: true, // Interval in milliseconds to calculate and trigger progress events: progressInterval: 100, // Interval in milliseconds to calculate progress bitrate: bitrateInterval: 500, // By default, uploads are started automatically when adding files: autoUpload: true, // Error and info messages: messages: &#123; uploadedBytes: 'Uploaded bytes exceed file size' &#125;, // Translation function, gets the message key to be translated // and an object with context specific data as arguments: i18n: function (message, context) &#123; message = this.messages[message] || message.toString(); if (context) &#123; $.each(context, function (key, value) &#123; message = message.replace('&#123;' + key + '&#125;', value); &#125;); &#125; return message; &#125;, // Additional form data to be sent along with the file uploads can be set // using this option, which accepts an array of objects with name and // value properties, a function returning such an array, a FormData // object (for XHR file uploads), or a simple object. // The form of the first fileInput is given as parameter to the function: formData: function (form) &#123; return form.serializeArray(); &#125;, // The add callback is invoked as soon as files are added to the fileupload // widget (via file input selection, drag &amp; drop, paste or add API call). // If the singleFileUploads option is enabled, this callback will be // called once for each file in the selection for XHR file uploads, else // once for each file selection. // // The upload starts when the submit method is invoked on the data parameter. // The data object contains a files property holding the added files // and allows you to override plugin options as well as define ajax settings. // // Listeners for this callback can also be bound the following way: // .bind('fileuploadadd', func); // // data.submit() returns a Promise object and allows to attach additional // handlers using jQuery's Deferred callbacks: // data.submit().done(func).fail(func).always(func); add: function (e, data) &#123; if (e.isDefaultPrevented()) &#123; return false; &#125; if (data.autoUpload || (data.autoUpload !== false &amp;&amp; $(this).fileupload('option', 'autoUpload'))) &#123; data.process().done(function () &#123; data.submit(); &#125;); &#125; &#125;, // Other callbacks: // Callback for the submit event of each file upload: // submit: function (e, data) &#123;&#125;, // .bind('fileuploadsubmit', func); // Callback for the start of each file upload request: // send: function (e, data) &#123;&#125;, // .bind('fileuploadsend', func); // Callback for successful uploads: // done: function (e, data) &#123;&#125;, // .bind('fileuploaddone', func); // Callback for failed (abort or error) uploads: // fail: function (e, data) &#123;&#125;, // .bind('fileuploadfail', func); // Callback for completed (success, abort or error) requests: // always: function (e, data) &#123;&#125;, // .bind('fileuploadalways', func); // Callback for upload progress events: // progress: function (e, data) &#123;&#125;, // .bind('fileuploadprogress', func); // Callback for global upload progress events: // progressall: function (e, data) &#123;&#125;, // .bind('fileuploadprogressall', func); // Callback for uploads start, equivalent to the global ajaxStart event: // start: function (e) &#123;&#125;, // .bind('fileuploadstart', func); // Callback for uploads stop, equivalent to the global ajaxStop event: // stop: function (e) &#123;&#125;, // .bind('fileuploadstop', func); // Callback for change events of the fileInput(s): // change: function (e, data) &#123;&#125;, // .bind('fileuploadchange', func); // Callback for paste events to the pasteZone(s): // paste: function (e, data) &#123;&#125;, // .bind('fileuploadpaste', func); // Callback for drop events of the dropZone(s): // drop: function (e, data) &#123;&#125;, // .bind('fileuploaddrop', func); // Callback for dragover events of the dropZone(s): // dragover: function (e) &#123;&#125;, // .bind('fileuploaddragover', func); // Callback before the start of each chunk upload request (before form data initialization): // chunkbeforesend: function (e, data) &#123;&#125;, // .bind('fileuploadchunkbeforesend', func); // Callback for the start of each chunk upload request: // chunksend: function (e, data) &#123;&#125;, // .bind('fileuploadchunksend', func); // Callback for successful chunk uploads: // chunkdone: function (e, data) &#123;&#125;, // .bind('fileuploadchunkdone', func); // Callback for failed (abort or error) chunk uploads: // chunkfail: function (e, data) &#123;&#125;, // .bind('fileuploadchunkfail', func); // Callback for completed (success, abort or error) chunk upload requests: // chunkalways: function (e, data) &#123;&#125;, // .bind('fileuploadchunkalways', func); // The plugin options are used as settings object for the ajax calls. // The following are jQuery ajax settings required for the file uploads: processData: false, contentType: false, cache: false, timeout: 0&#125;]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>jQueryFileUpload</tag>
        <tag>上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取全年法定节假日API]]></title>
    <url>%2Fblog%2F2019%2F03%2F21%2Fget-full-year-holiday%2F</url>
    <content type="text"><![CDATA[引言大家都知道，每年中国政府网2019年公休安排 %}都会公布法定节日调休安排，我们如何获取这些数据呢？ 开始获取某个月的节假日网上有一些现成的访问地址，提供了这些功能。如：http://www.easybots.cn/api/holiday.php?m=201901 直接访问后，返回JSON如下。12345678910111213&#123; "201901": &#123; "01": "2", "05": "2", "06": "2", "12": "2", "13": "1", "19": "2", "20": "1", "26": "2", "27": "1" &#125;&#125; 获取多个月的节假日后面可以接多个月份，如：http://www.easybots.cn/api/holiday.php?m=201901,201902,2019031234567891011121314151617181920212223242526272829303132333435363738&#123; "201901": &#123; "01": "2", "05": "1", "06": "1", "12": "2", "13": "1", "19": "2", "20": "1", "26": "2", "27": "2" &#125;, "201902": &#123; "04": "1", "05": "2", "06": "2", "07": "2", "08": "2", "09": "2", "10": "1", "16": "2", "17": "2", "23": "1", "24": "1" &#125;, "201903": &#123; "02": "1", "03": "2", "09": "2", "10": "2", "16": "1", "17": "2", "23": "1", "24": "1", "30": "1", "31": "2" &#125;&#125; 返回的JSON，1代表假日，2代表节日；由于是免费版本，代表节日或假日的标识符会随机变化，如果想要正确数据，请访问EasyBots.cn去购买。不过只需要区分节假日和工作日，不看标识符，那么这个数据还是正确的，包括调休。 获取某一天是否节假日如果只想获取某一天是否假日，可以把参数改一下，如：http://www.easybots.cn/api/holiday.php?d=20190103,20190104参数同样可以多个，不过要注意的是，对于免费版本来说，此数据不准确。 获取工作日完整Java代码下面就贴一份获取全年工作日的java代码片段：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 同步一年中的假期; */public void synWorkday() &#123; StringBuffer sbf = new StringBuffer(); try &#123; // 访问的地址替换当前年份 int currentYear = Calendar.getInstance().get(Calendar.YEAR); URL url = new URL(holiday_url.replaceAll("\\&#123;year\\&#125;", String.valueOf(currentYear))); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); // 插入启动钥匙 connection.setRequestMethod("GET"); // 热能装置链接 connection.connect(); // 打开电源 InputStream is = connection.getInputStream(); // 增加推力 BufferedReader reader = new BufferedReader(new InputStreamReader(is, "UTF-8")); String strRead = null; while ((strRead = reader.readLine()) != null) &#123; sbf.append(strRead); sbf.append("\r\n"); &#125; reader.close(); // 转换，假日JSON JSONObject map = JSON.parseObject(sbf.toString()); List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123; String year = entry.getKey(); // 拼接年份到结果集，然后生成新的list List&lt;String&gt; days = (List&lt;String&gt;) ((Map) entry.getValue()).keySet().stream().map(e -&gt; year + e).collect(Collectors.toList()); list.addAll(days); &#125; // 获取当年所有日期 List&lt;String&gt; currentYearFullDay = getYearFullDay(currentYear); // 移除假期，剩下工作日 currentYearFullDay.removeAll(list); // 排序从远端同步过来的假期数据 currentYearFullDay.sort(String::compareTo); // 查找现有数据库已经存储的数据 List&lt;Workday&gt; workdays = workdayRepository.findAllById(currentYearFullDay); // 转换List&lt;Workday&gt;为List&lt;String&gt;，方便删除重复数据 List&lt;String&gt; existList = workdays.stream().map(Workday::getWorkday).collect(Collectors.toList()); // 删除重复数据，只保留没有同步过的数据 currentYearFullDay.removeAll(existList); /**********这部分是入库操作，不需要入库的请忽略 start**********/ // 存储没有保存过的数据 for (String d : currentYearFullDay) &#123; Workday day = new Workday(); day.setWorkday(d); workdayRepository.save(day); &#125; /********** end **********/ &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;/** * 获取全年所有天; */private List&lt;String&gt; getYearFullDay(int year) &#123; List&lt;String&gt; fullDayList = new ArrayList&lt;&gt;(366); for (int i = 1; i &lt;= 12; i++) &#123; fullDayList.addAll(this.getMonthFullDay(year, i)); &#125; return fullDayList;&#125;/** * 获取某年某个月的所有天; */private List&lt;String&gt; getMonthFullDay(int year, int month) &#123; List&lt;String&gt; fullDayList = new ArrayList&lt;&gt;(31); SimpleDateFormat dateFormatYYYYMMDD = new SimpleDateFormat("yyyyMMdd"); // 获得当前日期对象 Calendar cal = Calendar.getInstance(); cal.clear();// 清除信息 cal.set(Calendar.YEAR, year); // 1月从0开始 cal.set(Calendar.MONTH, month - 1); // 当月1号 cal.set(Calendar.DAY_OF_MONTH, 1); int count = cal.getActualMaximum(Calendar.DAY_OF_MONTH); for (int j = 1; j &lt;= count; j++) &#123; fullDayList.add(dateFormatYYYYMMDD.format(cal.getTime())); cal.add(Calendar.DAY_OF_MONTH, 1); &#125; return fullDayList;&#125; 其他节假日API：goseekhttp://api.goseek.cn/Tools/holiday?date=20190202只有判断天是否节假日，0代表工作日，1代表节日，2代表假日，数据准确，但无节日的调休信息。 搜啊http://tool.bitefu.net/jiari/?d=2019http://tool.bitefu.net/jiari/?d=201902http://tool.bitefu.net/jiari/?d=20190203只返回法定节日，0代表工作日，1代表调休日，2代表节日，数据准确，但是无假日，也没有节日调休，周末的补班日。]]></content>
      <categories>
        <category>学习交流</category>
      </categories>
      <tags>
        <tag>节假日</tag>
        <tag>holiday</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo使用了nexT，但是无法push到github的问题解决]]></title>
    <url>%2Fblog%2F2019%2F03%2F14%2Fabout-nexT-cannot-push%2F</url>
    <content type="text"><![CDATA[clone主题nexT后，再push，发现github的文件夹是空的，没有提示错误，本地也完成了提交，无任何change，于是百度找原因，发现一个作者跟我有类似问题。 链接：https://calvinoshaw.github.io/2017/04/23/%E5%85%B3%E4%BA%8E-hexo-%E7%9A%84%E4%B8%BB%E9%A2%98%E6%96%87%E4%BB%B6%E5%A4%B9%E5%9B%A0%E4%B8%BA-modified-content-%E8%80%8C%E6%97%A0%E6%B3%95-push-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/ 但是我并没有按照上文作者的做法，我只是重新删除缓存，再次push就成功了。1234567891011121314151617181920git rm --cache themes/nextrm 'themes/next'git statusOn branch masterYour branch is up to date with 'origin/master'.Changes to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) new file: .idea/workspace.xml deleted: themes/nextgit add themes/next/git commit -m "commit nexT"git push origin master]]></content>
      <categories>
        <category>疑难杂症</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nexT</tag>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8中的Lambda表达式]]></title>
    <url>%2Fblog%2F2017%2F04%2F03%2Fjava8-lambda-expressions%2F</url>
    <content type="text"><![CDATA[原文地址：http://viralpatel.net/blogs/Lambda-expressions-java-tutorial/ Java是一流的面向对象语言，除了部分简单数据类型，Java 中的一切都是对象，即使数组也是一种对象，每个类创建的实例也是对象。在 Java 中定义的函数或方法不可能完全独立，也不能将方法作为参数或返回一个方法给实例。 从Swing开始，我们总是通过匿名类给方法传递函数功能，以下是旧版的事件监听代码：1234567someObject.addMouseListener(new MouseAdapter() &#123; public void mouseClicked(MouseEvent e) &#123; //Event listener implementation goes here... &#125; &#125;); 在上面的例子里，为了给 Mouse 监听器添加自定义代码，我们定义了一个匿名内部类 MouseAdapter 并创建了它的对象，通过这种方式，我们将一些函数功能传给 addMouseListener 方法。 简而言之，在 Java 里将普通的方法或函数像参数一样传值并不简单，为此，Java8 增加了一个语言级的新特性，名为Lambda表达式。 为什么Java需要Lambda表达式？如果忽视注解(Annotations)、泛型(Generics)等特性，自Java语言诞生时起，它的变化并不大。Java一直都致力维护其对象至上的特征，在使用过JavaScript之类的函数式语言之后，Java如何强调其面向对象的本质，以及源码层的数据类型如何严格变得更加清晰可感。其实，函数对Java 而言并不重要，在 Java的世界里，函数无法独立存在。在函数式编程语言中，函数是一等公民，它们可以独立存在，你可以将其赋值给一个变量，或将他们当做参数传给其他函数。JavaScript是最典型的函数式编程语言。点击此处以及此处可以清楚了解 JavaScript 这种函数式语言的好处。函数式语言提供了一种强大的功能——闭包，相比于传统的编程方法有很多优势，闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。Java现在提供的最接近闭包的概念便是Lambda 表达式，虽然闭包与 Lambda表达式之间存在显著差别，但至少Lambda表达式是闭包很好的替代者。 Lambda表达式为Java添加了缺失的函数式编程特点，使我们能将函数当做一等公民看待。尽管不完全正确，我们很快就会见识到Lambda与闭包的不同之处，但是又无限地接近闭包。在支持一类函数的语言中，Lambda表达式的类型将是函数。但是，在Java中，Lambda表达式是对象，他们必须依附于一类特别的对象类型——函数式接口(functional interface)。我们会在后文详细介绍函数式接口。 Mario Fusco的这篇思路清晰的文章介绍了为什么Java需要Lambda表达式。他解释了为什么现代编程语言必须包含闭包这类特性。 Lambda表达式简介Lambda表达式是一种匿名函数(对Java而言这并不完全正确，但现在姑且这么认为)，简单地说，它是没有声明的方法，也即没有访问修饰符、返回值声明和名字。 你可以将其想做一种速记，在你需要使用某个方法的地方写上它。当某个方法只使用一次，而且定义很简短，使用这种速记替代之尤其有效，这样，你就不必在类中费力写声明与方法了。 Java中的Lambda表达式通常使用(argument) -&gt; (body)语法书写，例如：123(arg1, arg2...) -&gt; &#123; body &#125;(type1 arg1, type2 arg2...) -&gt; &#123; body &#125; 以下是一些Lambda表达式的例子：123456789(int a, int b) -&gt; &#123; return a + b; &#125;() -&gt; System.out.println("Hello World");(String s) -&gt; &#123; System.out.println(s); &#125;() -&gt; 42() -&gt; &#123; return 3.1415 &#125;; Lambda表达式的结构让我们了解一下Lambda表达式的结构。 一个Lambda表达式可以有零个或多个参数； 参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同； 所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b)或 (int a, int b)或(String a, int b, float c)； 空圆括号代表参数集为空。例如：() -&gt; 42； 当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -&gt; return a*a； Lambda表达式的主体可包含零条或多条语句； 如果Lambda表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致； 如果Lambda表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空； 什么是函数式接口在Java中，Marker（标记）类型的接口是一种没有方法或属性声明的接口，简单地说，marker接口是空接口。相似地，函数式接口是只包含一个抽象方法声明的接口。 java.lang.Runnable就是一种函数式接口，在Runnable接口中只声明了一个方法void run()，相似地，ActionListener接口也是一种函数式接口，我们使用匿名内部类来实例化函数式接口的对象，有了Lambda表达式，这一方式可以得到简化。 每个Lambda表达式都能隐式地赋值给函数式接口，例如，我们可以通过Lambda表达式创建Runnable接口的引用。1Runnable r = () -&gt; System.out.println("hello world"); 当不指明函数式接口时，编译器会自动解释这种转化：123new Thread( () -&gt; System.out.println("hello world")).start(); 因此，在上面的代码中，编译器会自动推断：根据线程类的构造函数签名public Thread(Runnable r) { }，将该Lambda表达式赋给Runnable接口。 以下是一些Lambda表达式及其函数式接口：12345Consumer&lt;Integer&gt; c = (int x) -&gt; &#123; System.out.println(x) &#125;;BiConsumer&lt;Integer, String&gt; b = (Integer x, String y) -&gt; System.out.println(x + " : " + y);Predicate&lt;String&gt; p = (String s) -&gt; &#123; s == null &#125;; @FunctionalInterface是Java8新加入的一种接口，用于指明该接口类型声明是根据Java语言规范定义的函数式接口。Java8还声明了一些Lambda表达式可以使用的函数式接口，当你注释的接口不是有效的函数式接口时，可以使用@FunctionalInterface解决编译层面的错误。 以下是一种自定义的函数式接口：12345@FunctionalInterfacepublic interface WorkerInterface &#123; public void doSomeWork();&#125; 根据定义，函数式接口只能有一个抽象方法，如果你尝试添加第二个抽象方法，将抛出编译时错误。例如：12345678@FunctionalInterfacepublic interface WorkerInterface &#123; public void doSomeWork(); public void doSomeMoreWork();&#125; 错误：123Unexpected @FunctionalInterface annotation @FunctionalInterface ^ WorkerInterface is not a functional interface multiple non-overriding abstract methods found in interface WorkerInterface 1 error 函数式接口定义好后，我们可以在 API 中使用它，同时利用Lambda表达式。例如：1234567891011121314151617181920212223242526272829 //定义一个函数式接口@FunctionalInterfacepublic interface WorkerInterface &#123; public void doSomeWork();&#125;public class WorkerInterfaceTest &#123; public static void execute(WorkerInterface worker) &#123; worker.doSomeWork(); &#125; public static void main(String [] args) &#123; //invoke doSomeWork using Annonymous class execute(new WorkerInterface() &#123; @Override public void doSomeWork() &#123; System.out.println("Worker invoked using Anonymous class"); &#125; &#125;); //invoke doSomeWork using Lambda expression execute( () -&gt; System.out.println("Worker invoked using Lambda expression") ); &#125;&#125; 输出：12Worker invoked using Anonymous class Worker invoked using Lambda expression 这上面的例子里，我们创建了自定义的函数式接口并与Lambda表达式一起使用。execute()方法现在可以将Lambda表达式作为参数。 Lambda表达式举例学习Lambda表达式的最好方式是学习例子。 线程可以通过以下方法初始化：123456789101112// 旧方法new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("Hello from thread"); &#125;&#125;).start();// 新方法new Thread( () -&gt; System.out.println("Hello from thread")).start(); 事件处理可以使用Java8的Lambda表达式解决。下面的代码中，我们将使用新旧两种方式向一个UI组件添加ActionListener：123456789101112// 旧方法button.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println("The button was clicked using old fashion code!"); &#125;&#125;);// 新方法button.addActionListener( (e) -&gt; &#123; System.out.println("The button was clicked. From Lambda expressions !");&#125;); 以下代码的作用是打印出给定数组中的所有元素。注意，使用Lambda表达式的方法不止一种。在下面的例子中，我们先是用常用的箭头语法创建Lambda表达式，之后，使用Java8全新的双冒号(::)操作符将一个常规方法转化为Lambda表达式：123456789101112// 旧方法List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7);for(Integer n: list) &#123; System.out.println(n);&#125;// 新方法List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7);list.forEach(n -&gt; System.out.println(n));//or we can use :: double colon operator in Java 8list.forEach(System.out::println); 在下面的例子中，我们使用断言(Predicate)函数式接口创建一个测试，并打印所有通过测试的元素，这样，你就可以使用Lambda表达式规定一些逻辑，并以此为基础有所作为：1234567891011121314151617181920212223242526272829303132333435import java.util.Arrays;import java.util.List;import java.util.function.Predicate;public class Main &#123; public static void main(String [] a) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7); System.out.println("Print all numbers:"); evaluate(list, (n)-&gt;true); System.out.println("Print no numbers:"); evaluate(list, (n)-&gt;false); System.out.println("Print even numbers:"); evaluate(list, (n)-&gt; n%2 == 0 ); System.out.println("Print odd numbers:"); evaluate(list, (n)-&gt; n%2 == 1 ); System.out.println("Print numbers greater than 5:"); evaluate(list, (n)-&gt; n &gt; 5 ); &#125; public static void evaluate(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123; for(Integer n: list) &#123; if(predicate.test(n)) &#123; System.out.println(n + " "); &#125; &#125; &#125;&#125; 输出：12345Print all numbers: 1 2 3 4 5 6 7 Print no numbers: Print even numbers: 2 4 6 Print odd numbers: 1 3 5 7 Print numbers greater than 5: 6 7 下面的例子使用Lambda表达式打印数值中每个元素的平方，注意我们使用了.stream()方法将常规数组转化为流。Java8增加了一些超棒的流APIs。java.util.stream.Stream接口包含许多有用的方法，能结合Lambda表达式产生神奇的效果。我们将Lambda表达式x -&gt; x*x传给map()方法，该方法会作用于流中的所有元素。之后，我们使用forEach方法打印数据中的所有元素：12345678910// 旧方法List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7);for(Integer n : list) &#123; int x = n * n; System.out.println(x);&#125;// 新方法List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7);list.stream().map((x) -&gt; x*x).forEach(System.out::println); 下面的例子会计算给定数值中每个元素平方后的总和。请注意，Lambda表达式只用一条语句就能达到此功能，这也是MapReduce的一个初级例子。我们使用map()给每个元素求平方，再使用reduce()将所有元素计入一个数值：12345678910111213// 旧方法List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7);int sum = 0;for(Integer n : list) &#123; int x = n * n; sum = sum + x;&#125;System.out.println(sum);// 新方法List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7);int sum = list.stream().map(x -&gt; x*x).reduce((x,y) -&gt; x + y).get();System.out.println(sum); Lambda表达式与匿名类的区别使用匿名类与Lambda表达式的一大区别在于关键词的使用。对于匿名类，关键词this解读为匿名类，而对于Lambda表达式，关键词this解读为写就Lambda的外部类。 Lambda表达式与匿名类的另一不同在于两者的编译方法。Java编译器编译Lambda表达式并将他们转化为类里面的私有函数，它使用Java7中新加的invokedynamic指令动态绑定该方法，关于Java如何将Lambda表达式编译为字节码，Tal Weiss写了一篇很好的文章。]]></content>
      <categories>
        <category>技术交流</category>
      </categories>
      <tags>
        <tag>lambda</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解javascript this指向什么？]]></title>
    <url>%2Fblog%2F2016%2F07%2F14%2Fjs-this%2F</url>
    <content type="text"><![CDATA[转自：http://www.cnblogs.com/isaboy/archive/2015/10/29/javascript_this.html JavaScript 是一种脚本语言，支持函数式编程、闭包、基于原型的继承等高级功能。JavaScript一开始看起来感觉会很容易入门，但是随着使用的深入，你会发现JavaScript其实很难掌握，有些基本概念让人匪夷所思。其中JavaScript 中的 this 关键字，就是一个比较容易混乱的概念，在不同的场景下，this会化身不同的对象。有一种观点认为，只有正确掌握了 JavaScript 中的 this 关键字，才算是迈入了 JavaScript 这门语言的门槛。在主流的面向对象的语言中（例如Java,C#等)，this 含义是明确且具体的，即指向当前对象。一般在编译期绑定。而 JavaScript 中this 在运行期进行绑定的，这是JavaScript 中this 关键字具备多重含义的本质原因。 JavaScript由于其在运行期进行绑定的特性，JavaScript 中的 this 可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。JavaScript 中函数的调用有以下几种方式：作为对象方法调用，作为函数调用，作为构造函数调用，和使用 apply 或 call 调用。常言道，字不如表，表不如图。为了让人更好的理解JavaScript this 到底指向什么？下面用一张图来进行解释： 上图我称之为”JavaScript this决策树”（非严格模式下）。下面通过例子来说明这个图如何来帮助我们对this进行判断：1234567891011var point = &#123; x : 0, y : 0, moveTo : function(x, y) &#123; this.x = this.x + x; this.y = this.y + y; &#125; &#125;; //决策树解释：point.moveTo(1,1)函数不是new进行调用，进入否决策， //是用dot(.)进行调用，则指向.moveTo之前的调用对象，即point point.moveTo(1,1); //this 绑定到当前对象,即point对象point.moveTo（）函数在 “JavaScript this决策树”中进行判定的过程是这样的： 1）point.moveTo函数调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？； 2）point.moveTo函数是用dot(.)进行调用的，即进入“是”分支，即这里的this指向point.moveTo中.之前的对象point; 图解point.moveTo函数的this指向什么的解析图如下图所示： 再举例，看下面的代码：123456function func(x) &#123; this.x = x; &#125;func(5);//this是全局对象window，x为全局变量//决策树解析：func()函数是用new进行调用的么？为否，进入func()函数是用dot进行调用的么？为否，则 this指向全局对象windowx;//x =&gt; 5 func（）函数在 “JavaScript this决策树”中进行判定的过程是这样的： 1）func(5)函数调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？； 2）func(5)函数不是用dot(.)进行调用的，即进入“否”分支，即这里的this指向全局变量window，那么this.x实际上就是window.x; 图解func函数的this指向什么的解析图如下图所示： 针对作为函数直接调用的方式，下面看一个复杂的例子：123456789101112131415161718192021var point = &#123; x : 0, y : 0, moveTo : function(x, y) &#123; // 内部函数 var moveX = function(x) &#123; this.x = x;//this 指向什么？window &#125;; // 内部函数 var moveY = function(y) &#123; this.y = y;//this 指向什么？window &#125;; moveX(x); moveY(y); &#125; &#125;; point.moveTo(1,1); point.x; //=&gt;0 point.y; //=&gt;0 x; //=&gt;1 y; //=&gt;1 point.moveTo(1,1)函数实际内部调用的是moveX()和moveY()函数, moveX()函数内部的this在 “JavaScript this决策树”中进行判定的过程是这样的： 1）moveX(1)函数调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？； 2）moveX(1)函数不是用dot(.)进行调用的，即进入“否”分支，即这里的this指向全局变量window，那么this.x实际上就是window.x; 下面看一下作为构造函数调用的例子：123456789function Point(x,y)&#123; this.x = x; // this ? this.y = y; // this ? &#125;var np=new Point(1,1);np.x;//1var p=Point(2,2);p.x;//error, p是一个空对象undefinedwindow.x;//2 Point(1,1)函数在var np=new Point(1,1)中的this在 “JavaScript this决策树”中进行判定的过程是这样的： 1）var np=new Point(1,1)调用是用new进行调用的么？这个明显是，进入“是”分支，即this指向np； 2）那么this.x=1，即np.x=1； Point(2,2)函数在var p= Point(2,2)中的this在 “JavaScript this决策树”中进行判定的过程是这样的： 1）var p= Point(2,2)调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？； 2）Point(2,2)函数不是用dot(.)进行调用的？判定为否，即进入“否”分支，即这里的this指向全局变量window，那么this.x实际上就是window.x; 3）this.x=2即window.x=2. 最后看一下函数用call 和apply进行调用的例子：12345678910111213function Point(x, y)&#123; this.x = x; this.y = y; this.moveTo = function(x, y)&#123; this.x = x; this.y = y; &#125; &#125;var p1 = new Point(0, 0);var p2 = &#123;x: 0, y: 0&#125;;p1.moveTo.apply(p2, [10, 10]);//apply实际上为p2.moveTo(10,10)p2.x//10 p1.moveTo.apply(p2,[10,10])函数在 “JavaScript this决策树”中进行判定的过程是这样的：我们知道，apply 和 call 这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this绑定的对象。p1.moveTo.apply(p2,[10,10])实际上是p2.moveTo(10,10)。那么p2.moveTo(10,10)可解释为： 1）p2.moveTo(10,10)函数调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？； 2）p2.moveTo(10,10)函数是用dot(.)进行调用的，即进入“是”分支，即这里的this指向p2.moveTo(10,10)中.之前的对象p2,所以p2.x=10;关于JavaScript函数执行环境的过程，IBM developerworks文档库中的一段描述感觉很不错，摘抄如下： “JavaScript 中的函数既可以被当作普通函数执行，也可以作为对象的方法执行，这是导致 this 含义如此丰富的主要原因。一个函数被执行时，会创建一个执行环境（ExecutionContext），函数的所有的行为均发生在此执行环境中，构建该执行环境时，JavaScript 首先会创建arguments变量，其中包含调用函数时传入的参数。接下来创建作用域链。然后初始化变量，首先初始化函数的形参表，值为 arguments变量中对应的值，如果 arguments变量中没有对应值，则该形参初始化为 undefined。如果该函数中含有内部函数，则初始化这些内部函数。如果没有，继续初始化该函数内定义的局部变量，需要注意的是此时这些变量初始化为 undefined，其赋值操作在执行环境（ExecutionContext）创建成功后，函数执行时才会执行，这点对于我们理解 JavaScript 中的变量作用域非常重要，鉴于篇幅，我们先不在这里讨论这个话题。最后为 this变量赋值，如前所述，会根据函数调用方式的不同，赋给 this全局对象，当前对象等。至此函数的执行环境（ExecutionContext）创建成功，函数开始逐行执行，所需变量均从之前构建好的执行环境（ExecutionContext）中读取。” 理解这段话对于理解Javascript函数将大有好处。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30 分钟 git 命令入门]]></title>
    <url>%2Fblog%2F2016%2F06%2F29%2Flearn-git-in-30-minutes%2F</url>
    <content type="text"><![CDATA[转自：http://www.w3ctrain.com/2016/06/26/learn-git-in-30-minutes/ 这是一篇给像我这样的新手或者是熟悉图形工具的老鸟看的。仅作为快速入门的教程。 git 现在的火爆程度非同一般，它被广泛地用在大型开源项目，团队开发，以及独立开发者，甚至学生之中。 初学者非常容易被各种命令，参数吓哭。但实际上刚上手你并不需要了解所有命令的用途。你可以从掌握一些简单，强大的命令开始，逐步去学习。（这就是这篇文章要讲的）。好了，上来！ 基本了解git命令是一些命令行工具的集合，它可以用来跟踪，记录文件的变动。比如你可以进行保存，比对，分析，合并等等。这个过程被称之为版本控制。已经有一系列的版本控制系统，比如SVN, Mercurial, Perforce, CVS, Bitkeepe等等。 Git是分布式的，这意味着它并不依赖于中心服务器，任何一台机器都可以有一个本地版本的控制系统，我们称之为仓库。如果是多人协作的话，你需要还需要一个线上仓库，用来同步信息。这就是GitHub, BitBucket的工作。 安装Git安装git非常直接： Linux – 打开控制台，然后通过包管理安装，在Ubuntu上命令是：1sudo apt-get install git-all Windows – 推荐使用git for windows，它包括了图形工具以及命令行模拟器。 OS X – 最简单的方式是使用homebrew安装，命令行执行1brew install git 如果你是在是先用图形工具的话，那么推荐你使用Github desktop,Sourcetree。但我还是推荐你使用命令行，下面的内容就都是命令行的。 配置Git安装完git,首要任务是配置我们的信息，最重要的是用户名及邮箱，打开终端，执行以下命令。 12$ git config --global user.name "My Name"$ git config --global user.email myEmail@example.com 配置好这两项，用户就能知道谁做了什么，并且一切都更有组织性了不是吗？ 创建一个新仓库 – git initgit 会把所有文件以及历史记录保存在你的项目中，创建一个新的仓库，首先要去到项目路径，执行 git init。然后git会创建一个隐藏的文件夹.git，所有的信息都储存在其中。 在桌面创建一个联系文件夹 git_exercise, 打开终端：12$ cd Desktop/git_exercise/$ git init OK，现在项目还什么都没有，新建一个 hello.txt 文件试试~ 检查状态 – git statusgit status 是另一个非常重要的命令，它会告诉我们创库的当前状态：是否为最新代码，有什么更新等等执行git status:12345678910$ git statusOn branch masterInitial commitUntracked files: (use "git add ..." to include in what will be committed)hello.txt git 告诉我们，hello.txt尚未跟踪，这是因为这个文件是新的，git不知道是应该跟踪它的变动呢，还是直接忽略不管呢。为了跟踪我们的新文件，我们需要暂存它。 暂存 – git addgit 有个概念叫 暂存区，你可以把它看成一块空白帆布，包裹着所有你可能会提交的变动。它一开始为空，你可以通过 git add 命令添加内容，并使用 git commit 提交。 这个例子中只有一个文件：1$ git add hello.txt 如果需要提交目录下的所有内容，可以这样：1$ git add -A 再次使用git status查看：123456789$ git statusOn branch masterInitial commitChanges to be committed: (use "git rm --cached ..." to unstage)new file: hello.txt 我们的文件已经提交了。状态信息还会告诉我们暂存区文件发生了什么变动，不过这里我们提交的是一个全新文件。 提交 – git commit一次提交代表着我们的仓库到了一个交付状态，通常是完成了某一块小功能。它就像是一个快照，允许我们像使用时光机一样回到旧时光。 创建提交，需要我们提交东西到暂存区（git add），然后：1$ git commit -m "Initial commit." 这就创建了一次提交，-m “Initial commit.”表示对这次提交的描述，建议使用有意义的描述性信息。 远端仓库到目前为止，我们的操作都是在本地的，它存在于.git文件中。为了能够协同开发，我们需要把代码发布到远端仓库上。 链接远端仓库 – git remote add为了能够上传到远端仓库，我们需要先建立起链接，这篇教程中，远端仓库的地址为：https://github.com/tutorialzine/awesome-project， 但你应该自己在Github, BitBucket上搭建仓库，自己一步一步尝试。 添加测试用的远端仓库。1$ git remote add origin https://github.com/tutorialzine/awesome-project.git 一个项目可以同时拥有好几个远端仓库为了能够区分，通常会起不同的名字。通常主远端仓库被称为origin。 上传到服务器 – git push每次我们要提交代码到服务器上时，都会使用到git push。 git push命令会有两个参数，远端仓库的名字，以及分支的名字：1234567$ git push origin masterCounting objects: 3, done.Writing objects: 100% (3/3), 212 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To https://github.com/tutorialzine/awesome-project.git* [new branch] master -&gt; master 取决于你使用的服务器，push过程你可能需要验证身份。如果没有出差错，现在使用浏览器去你的远端分支上看，hello.txt已经在那里等着你了。 克隆仓库 – git clone放在Github上的开源项目，人们可以看到你的代码。可以使用 git clone进行下载到本地。1$git clone https://github.com/tutorialzine/awesome-project.git 本地也会创建一个新的仓库，并自动将github上的分支设为远端分支。 从服务器上拉取代码 – git pull如果你更新了代码到仓库上，其他人可以通过git pull命令拉取你的变动：1234$ git pull origin masterFrom https://github.com/tutorialzine/awesome-project* branch master -&gt; FETCH_HEADAlready up-to-date. 因为暂时没有其他人提交，所有没有任何变动 分支当你在做一个新功能的时候，最好是在一个独立的区域上开发，通常称之为分支。分支之间相互独立，并且拥有自己的历史记录。这样做的原因是： 稳定版本的代码不会被破坏不同的功能可以由不同开发者同时开发。开发者可以专注于自己的分支，不用担心被其他人破坏了环境在不确定之前，同一个特性可以拥有几个版本，便于比较 创建新分支 – git branch每一个仓库的默认分支都叫master, 创建新分支可以这样：1$ git branch amazing_new_feature 创建了一个名为amazing_new_feature的新分支，它跟当前分支同一起点。 切换分支 – git checkout单独使用git branch，可以查看分支状态：123$ git branch amazing_new_feature* master *号表示当前活跃分支为master，使用git checkout切换分支。1$ git checkout amazing_new_feature 合并分支 – git merge我们的 amazing_new_feature 分支的任务是增加一个featuer.txt。我们来创建，添加到暂存区，提交。12$ git add feature.txt$ git commit -m "New feature complete." 新分支任务完成了，回到master分支1$ git checkout master 现在去查看文件，你会发现，之前创建的feature.txt文件不见了，因为master分支上并没有feature.txt。使用git merge 把 amazing_new_feature 分支合并到master上。1$ git merge amazing_new_feature ok! 然后再把amazing_new_feature 分支删掉吧。1$ git branch -d amazing_new_feature 高级这篇文章的最后一节，我们来说些比较高级并且使用的技巧。 比对两个不同提交之间的差别每次提交都有一个唯一id，查看所有提交和他们的id，可以使用 git log:12345678910111213141516171819$ git logcommit ba25c0ff30e1b2f0259157b42b9f8f5d174d80d7Author: TutorialzineDate: Mon May 30 17:15:28 2016 +0300 New feature completecommit b10cc1238e355c02a044ef9f9860811ff605c9b4Author: TutorialzineDate: Mon May 30 16:30:04 2016 +0300 Added content to hello.txtcommit 09bd8cc171d7084e78e4d118a2346b7487dca059Author: TutorialzineDate: Sat May 28 17:52:14 2016 +0300 Initial commit id 很长，但是你并不需要复制整个字符串，前一小部分就够了。 查看某一次提交更新了什么，使用 git show:1234567891011121314$ git show b10cc123commit b10cc1238e355c02a044ef9f9860811ff605c9b4Author: TutorialzineDate: Mon May 30 16:30:04 2016 +0300 Added content to hello.txtdiff --git a/hello.txt b/hello.txtindex e69de29..b546a21 100644--- a/hello.txt+++ b/hello.txt -0,0 +1+Nice weather today, isn't it? 查看两次提交的不同，可以使用git diff [commit-from]..[commit-to] 语法：1234567891011$ git diff 09bd8cc..ba25c0ffdiff --git a/feature.txt b/feature.txtnew file mode 100644index 0000000..e69de29diff --git a/hello.txt b/hello.txtindex e69de29..b546a21 100644--- a/hello.txt+++ b/hello.txt -0,0 +1+Nice weather today, isn't it? 比较首次提交和最后一次提交，我们可以看到所有的更改。当然使用git difftool命令更加方便。 回滚某个文件到之前的版本git 允许我们将某个特定的文件回滚到特定的提交，使用的也是 git checkout。下面的例子，我们将hello.txt回滚到最初的状态，需要指定回滚到哪个提交，以及文件的全路径。1$ git checkout 09bd8cc1 hello.txt 回滚提交如果你发现最新的一次提交完了加某个文件，你可以通过 git commit —amend来修复，它会把最新的提交打回暂存区，并尝试重新提交。 如果是更复杂的情况，比如不是最新的提交了。那你可以使用git revert。 最新的一次提交别名也叫HEAD。1$ git revert HEAD 其他提交可以使用id:1$ git revert b10cc123 混滚提交时，发生冲突是非常频繁的。当文件被后面的提交修改了以后，git不能正确回滚。 解决合并冲突冲突经常出现在合并分支或者是拉去别人的代码。有些时候git能自动处理冲突，但大部分需要我们手动处理。 比如John 和 Tim 分别在各自的分支上写了两部分代码。 John 喜欢 for:123// Use a for loop to console.log contents.for(var i=0; i console.log(arr[i]);&#125; Tim 喜欢 forEach:1234// Use forEach to console.log contents.arr.forEach(function(item) &#123;console.log(item);&#125;); 假设John 现在去拉取 Tim的代码:12345$ git merge tim_branchAuto-merging print_array.jsCONFLICT (content): Merge conflict in print_array.jsAutomatic merge failed; fix conflicts and then commit the result. 这时候git并不知道如何解决冲突，因为他不知道John和Tim谁写得更好。 于是它就在代码中插入标记。1234567891011HEAD// Use a for loop to console.log contents.for(var i=0; iarr.length; i++) &#123; console.log(arr[i]);&#125;=======// Use forEach to console.log contents.arr.forEach(function(item) &#123; console.log(item);&#125;);&gt;&gt;&gt;&gt;&gt;&gt;&gt; Tim s commit. ==== 号上方是当前最新一次提交，下方是冲突的代码。我们需要解决这样的冲突，经过组委会成员讨论，一致认定，在座的各位都是垃圾！两个都不要。改成下面的代码。123// Not using for loop or forEach.// Use Array.toString() to console.log contents.console.log(arr.toString()); 好了，再提交一下：12$ git add -A$ git commit -m "Array printing conflict resolved." 如果在大型项目中，这个过程可能容易出问题。你可以使用GUI 工具来帮助你。使用 git mergetool。 配置 .gitignore大部分项目中，会有写文件，文件夹是我们不想提交的。为了防止一不小心提交，我们需要gitignore文件： 在项目根目录创建.gitignore文件在文件中列出不需要提交的文件名，文件夹名，每个一行.gitignore文件需要提交，就像普通文件一样通常会被ignore的文件有： log文件task runner buildsnode_modules等文件夹IDEs生成的文件个人笔记 例如：*.logbuild/node_modules/.idea/my_notes.txt]]></content>
      <categories>
        <category>学习交流</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
